#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model Modelica_Requirements.Examples.Elementary.ChecksInSlidingWindow.BandDuration
 Dymola Version 2023x Refresh 1, 2023-04-12 translated this at Wed Aug 16 17:01:10 2023

   */

#include <matrixop.h>
#include "matrixop.c"
/* Declaration of C-structs */
struct DymStruc0;
struct DymStruc1;
struct DymStruc0 {
  int  id_0member;
};
DYMOLA_STATIC struct DymStruc0 DymStruc0_construct(int   id_02) {
  struct DymStruc0 dummy_0;
  dummy_0.id_0member = id_02;
  return dummy_0;
}
struct DymStruc1 {
  double  T_0member;
  double  t0_0member;
  RealArray   t_0member;
  IntegerArray   b_0member;
  int  first_0member;
  int  last_0member;
  int  nElem_0member;
};
DYMOLA_STATIC struct DymStruc1 DymStruc1_construct(double   T_02, IntegerArray  
    b_02, int   first_02, int   last_02, int   nElem_02, RealArray    t_02, 
  double   t0_02) {
  struct DymStruc1 dummy_0;
  dummy_0.T_0member = T_02;
  dummy_0.b_0member = b_02;
  dummy_0.first_0member = first_02;
  dummy_0.last_0member = last_02;
  dummy_0.nElem_0member = nElem_02;
  dummy_0.t_0member = t_02;
  dummy_0.t0_0member = t0_02;
  return dummy_0;
}
/* Prototypes for functions used in model */
#include "ModelicaStandardTables.h"
DYMOLA_STATIC void Modelica_Blocks_Sources_BooleanTable_isValidTable(RealArray  
   table0_0);
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getNextTimeEvent_M(
  struct DymStruc0 tableID0_0, double  timeIn0_0);
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTimeTableTmax_M(
  struct DymStruc0 tableID0_0);
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTimeTableTmin_M(
  struct DymStruc0 tableID0_0);
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTimeTableValueNoDer_M(
  struct DymStruc0 tableID0_0, int  icol0_0, double  timeIn0_0, double  
  nextTimeEvent0_0, double  prex_0nextTimeEvent);
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTimeTable_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, 
  double  startTime0_0, IntegerArray   columns0_0, int  smoothness0_0, int  
  extrapolation0_0, double  shiftTime0_0, int  timeEvents0_0, int  
  verboseRead0_0, int id_, int alwaysMakeNew_);
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTimeTable_destructor_M(
  void* externalCombiTimeTable0_0);
DYMOLA_STATIC int   Modelica_Utilities_Strings_isEmpty(const char*  string0_0);
DYMOLA_STATIC struct DymStruc1  Modelicax_0Requirements_Internal_SlidingWindow_Buffer
  (double  T0_0, double  t00_0, RealArray   t0_0, IntegerArray   b0_0, int  
  first0_0, int  last0_0, int  nElem0_0);
DYMOLA_STATIC int   Modelicax_0Requirements_Internal_SlidingWindow_firstValue(
  struct DymStruc1 buffer0_0);
DYMOLA_STATIC double   Modelicax_0Requirements_Internal_SlidingWindow_indexTime(
  struct DymStruc1 buffer0_0, int  index0_0);
DYMOLA_STATIC int   Modelicax_0Requirements_Internal_SlidingWindow_indexValue(
  struct DymStruc1 buffer0_0, int  index0_0);
DYMOLA_STATIC struct DymStruc1  Modelicax_0Requirements_Internal_SlidingWindow_init
  (double  T0_0, double  t00_0);
DYMOLA_STATIC int   Modelicax_0Requirements_Internal_SlidingWindow_lastValue(
  struct DymStruc1 buffer0_0);
DYMOLA_STATIC double   Modelicax_0Requirements_Internal_SlidingWindow_maxDuration
  (struct DymStruc1 buffer0_0, double  t0_0, int  b0_0);
DYMOLA_STATIC struct DymStruc1  Modelicax_0Requirements_Internal_SlidingWindow_push
  (struct DymStruc1 buffer0_0, double  t0_0, int  b0_0);
/* Codes used in model */

/* Flattened Modelica model:

function Modelica.Blocks.Sources.BooleanTable.isValidTable
discrete input Real table[:] "Vector of time instants";
protected 
Integer n(start = size(table, 1)) "Number of table points";
public 
algorithm 
if (n > 0) then 
for i in (2:n) loop
assert(table[i] > table[i-1], "Time values of table not strict monotonically increasing: table["+       String(i-1, true, 0)+"] = "+       String(table[i-1], true, 0)+", table["+       String(i, true, 0)+"] = "+       String(table[i], true, 0));
end for;
end if;
end Modelica.Blocks.Sources.BooleanTable.isValidTable;

  */
DYMOLA_STATIC void Modelica_Blocks_Sources_BooleanTable_isValidTable(RealArray  
   table0_0) {
  char*retSMark_=GetStringMark();
  PushContext("Modelica.Blocks.Sources.BooleanTable.isValidTable")
  {
    /* Declare outputs and temporaries */
    int   n0_0;
    MarkObject retmark_ = PushMark();
    n0_0 = DYNSizeSimple(table0_0, 1);
    /* Start of real code */
      if (n0_0 > 0) {
        {
          int end_ = n0_0;
          int i0_0_0;
          for(i0_0_0 = 2;i0_0_0 <= end_;i0_0_0 += 1) {
            AssertModelica(RealElement( table0_0, (SizeType)(i0_0_0)) > 
              RealElement( table0_0, (SizeType)(i0_0_0-1)),"table[i] > table[i-1]",
               StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
              StringAdd("Time values of table not strict monotonically increasing: table[",
              Integer2String2(i0_0_0-1, true, 0)),"] = "),Real2String2(
              RealElement( table0_0, (SizeType)(i0_0_0-1)), true, 0)),", table["),
              Integer2String2(i0_0_0, true, 0)),"] = "),Real2String2(
              RealElement( table0_0, (SizeType)(i0_0_0)), true, 0)));
          }
        }
      }
    /* Output section */
    PopMark(retmark_);
    SetStringMark(retSMark_);
    PopContext()
    return ;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Tables.Internal.getNextTimeEvent
discrete input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
discrete input Real timeIn "(Scaled) time value";
discrete output Real nextTimeEvent "(Scaled) next time event in table";

external "C" equation
nextTimeEvent = ModelicaStandardTables_CombiTimeTable_nextTimeEvent(tableID, timeIn) annotation(Include="#include \"ModelicaStandardTables.h\"", Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, IncludeDirectory="modelica://Modelica/Resources/C-Sources", LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Blocks.Tables.Internal.getNextTimeEvent;

  */
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getNextTimeEvent_M(
  struct DymStruc0 tableID0_0, double  timeIn0_0) {
  PushContext("Modelica.Blocks.Tables.Internal.getNextTimeEvent")
  {
    /* Declare outputs and temporaries */
    double   nextTimeEvent0_0;
    nextTimeEvent0_0=0;
    /* Start of real code */
    {
      nextTimeEvent0_0 = (ModelicaStandardTables_CombiTimeTable_nextTimeEvent)(
        externalTable_[tableID0_0.id_0member].obj_, timeIn0_0);
      }
    /* Output section */
    PopContext()
    return nextTimeEvent0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Tables.Internal.getTimeTableTmax
discrete input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
discrete output Real timeMax "Maximum abscissa value in table";

external "C" equation
timeMax = ModelicaStandardTables_CombiTimeTable_maximumTime(tableID) annotation(Include="#include \"ModelicaStandardTables.h\"", Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, IncludeDirectory="modelica://Modelica/Resources/C-Sources", LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Blocks.Tables.Internal.getTimeTableTmax;

  */
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTimeTableTmax_M(
  struct DymStruc0 tableID0_0) {
  PushContext("Modelica.Blocks.Tables.Internal.getTimeTableTmax")
  {
    /* Declare outputs and temporaries */
    double   timeMax0_0;
    timeMax0_0=0;
    /* Start of real code */
    {
      timeMax0_0 = (ModelicaStandardTables_CombiTimeTable_maximumTime)(
        externalTable_[tableID0_0.id_0member].obj_);
      }
    /* Output section */
    PopContext()
    return timeMax0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Tables.Internal.getTimeTableTmin
discrete input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
discrete output Real timeMin "Minimum abscissa value in table";

external "C" equation
timeMin = ModelicaStandardTables_CombiTimeTable_minimumTime(tableID) annotation(Include="#include \"ModelicaStandardTables.h\"", Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, IncludeDirectory="modelica://Modelica/Resources/C-Sources", LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Blocks.Tables.Internal.getTimeTableTmin;

  */
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTimeTableTmin_M(
  struct DymStruc0 tableID0_0) {
  PushContext("Modelica.Blocks.Tables.Internal.getTimeTableTmin")
  {
    /* Declare outputs and temporaries */
    double   timeMin0_0;
    timeMin0_0=0;
    /* Start of real code */
    {
      timeMin0_0 = (ModelicaStandardTables_CombiTimeTable_minimumTime)(
        externalTable_[tableID0_0.id_0member].obj_);
      }
    /* Output section */
    PopContext()
    return timeMin0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Tables.Internal.getTimeTableValueNoDer
discrete input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
input Integer icol "Column number";
discrete input Real timeIn "(Scaled) time value";
discrete input Real nextTimeEvent "(Scaled) next time event in table";
discrete input Real pre_nextTimeEvent "Pre-value of (scaled) next time event in table";
discrete output Real y "Interpolated value";

external "C" equation
y = ModelicaStandardTables_CombiTimeTable_getValue(tableID, icol, timeIn, nextTimeEvent, pre_nextTimeEvent) annotation(Include="#include \"ModelicaStandardTables.h\"", Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, IncludeDirectory="modelica://Modelica/Resources/C-Sources", LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Blocks.Tables.Internal.getTimeTableValueNoDer;

  */
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTimeTableValueNoDer_M(
  struct DymStruc0 tableID0_0, int  icol0_0, double  timeIn0_0, double  
  nextTimeEvent0_0, double  prex_0nextTimeEvent) {
  PushContext("Modelica.Blocks.Tables.Internal.getTimeTableValueNoDer")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
    {
      y0_0 = (ModelicaStandardTables_CombiTimeTable_getValue)(externalTable_[
        tableID0_0.id_0member].obj_, icol0_0, timeIn0_0, nextTimeEvent0_0, 
        prex_0nextTimeEvent);
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function constructor
input String tableName "Table name";
input String fileName "File name";
discrete input Real table[:, :];
discrete input Real startTime(unit = "s");
input Integer columns[:];
input Modelica.Blocks.Types.Smoothness smoothness;
input Modelica.Blocks.Types.Extrapolation extrapolation;
discrete input Real shiftTime(start = 0.0, unit = "s");
input Modelica.Blocks.Types.TimeEvents timeEvents(start = Modelica.Blocks.Types.TimeEvents.Always);
input Boolean verboseRead(start = true) "= true: Print info message; = false: No info message";
discrete output Modelica.Blocks.Types.ExternalCombiTimeTable externalCombiTimeTable;

external "C" equation
externalCombiTimeTable = ModelicaStandardTables_CombiTimeTable_init2(fileName, tableName, table, size(table, 1), size(table, 2), startTime, columns, size(columns, 1), smoothness, extrapolation, shiftTime, timeEvents, verboseRead) annotation(Include="#include \"ModelicaStandardTables.h\"", Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, IncludeDirectory="modelica://Modelica/Resources/C-Sources", LibraryDirectory="modelica://Modelica/Resources/Library");
end constructor;

  */
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTimeTable_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, 
  double  startTime0_0, IntegerArray   columns0_0, int  smoothness0_0, int  
  extrapolation0_0, double  shiftTime0_0, int  timeEvents0_0, int  
  verboseRead0_0, int id_, int alwaysMakeNew_) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTimeTable")
  {
    /* Declare outputs and temporaries */
    struct DymStruc0  externalCombiTimeTable0_0;
    externalCombiTimeTable0_0.id_0member=0;
    /* Start of real code */
    {
      externalCombiTimeTable0_0.id_0member=id_;
      if (externalTable_[id_].destructor_ && externalTable_[id_].obj_ && alwaysMakeNew_) {
      void*x_=externalTable_[id_].obj_;
      externalTable_[id_].obj_=0;
      (*(externalTable_[id_].destructor_))(x_);
      } else if (!externalTable_[id_].destructor_) {externalTable_[id_].obj_=0;}
      #if (defined(_OPENMP) && !defined(DISABLE_DYMOLA_OPENMP))
      if (!(externalTable_[id_].haveLock_)) {omp_init_lock(&(externalTable_[id_].lockExternal_));externalTable_[id_].haveLock_=1;}
      #endif
      externalTable_[id_].destructor_=Modelica_Blocks_Types_ExternalCombiTimeTable_destructor_M;

        if (!externalTable_[id_].obj_) externalTable_[id_].obj_ = (
        ModelicaStandardTables_CombiTimeTable_init2)(fileName0_0, tableName0_0, 
        table0_0.data, table0_0.dims[1-1], table0_0.dims[2-1], startTime0_0, 
        columns0_0.data, columns0_0.dims[1-1], smoothness0_0, extrapolation0_0, 
        shiftTime0_0, timeEvents0_0, verboseRead0_0);
      }
    /* Output section */
    PopContext()
    return externalCombiTimeTable0_0;
  }}

/* Flattened Modelica model:

function destructor
discrete input Modelica.Blocks.Types.ExternalCombiTimeTable externalCombiTimeTable;

external "C" equation
ModelicaStandardTables_CombiTimeTable_close(externalCombiTimeTable) annotation(Include="#include \"ModelicaStandardTables.h\"", Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, IncludeDirectory="modelica://Modelica/Resources/C-Sources", LibraryDirectory="modelica://Modelica/Resources/Library");
end destructor;

  */
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTimeTable_destructor_M(
  void* externalCombiTimeTable0_0) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTimeTable.destructor")
  {
    /* Declare outputs and temporaries */
    /* Start of real code */
    {
      (ModelicaStandardTables_CombiTimeTable_close)(externalCombiTimeTable0_0);
      }
    /* Output section */
    PopContext()
    return ;
  }}

/* Flattened Modelica model:

function Modelica.Utilities.Strings.isEmpty
input String string;
output Boolean result "True, if string is empty";
protected 
Integer nextIndex;
Integer len;
public 
algorithm 
nextIndex := ModelicaStrings_skipWhiteSpace(string, 1);
len := ModelicaStrings_length(string);
if (len < 1 or nextIndex > len) then 
result := true;
else
result := false;
end if;
end Modelica.Utilities.Strings.isEmpty;

  */
DYMOLA_STATIC int   Modelica_Utilities_Strings_isEmpty(const char*  string0_0) {
  PushContext("Modelica.Utilities.Strings.isEmpty")
  {
    /* Declare outputs and temporaries */
    int   result0_0;
    int   nextIndex0_0;
    int   len0_0;
    result0_0=0;
    nextIndex0_0=0;
    len0_0=0;
    /* Start of real code */
      nextIndex0_0 = ModelicaStrings_skipWhiteSpace(string0_0, 1);
      len0_0 = ModelicaStrings_length(string0_0);
      if (len0_0 < 1 OR nextIndex0_0 > len0_0) {
        result0_0 = true;
      }
      else{
        result0_0 = false;
      }
    /* Output section */
    PopContext()
    return result0_0;
  }}

/* Flattened Modelica model:

function Modelica_Requirements.Internal.SlidingWindow.init
discrete input Real T(unit = "s") "Length of window";
discrete input Real t0(unit = "s") "Initial time instant";
discrete output Modelica_Requirements.Internal.SlidingWindow.Buffer buffer(start = Modelica_Requirements.Internal.SlidingWindow.Buffer(T, t0, fill(0, 20), fill(false, 20), 0, 0, 0));

algorithm 
end Modelica_Requirements.Internal.SlidingWindow.init;

  */
DYMOLA_STATIC struct DymStruc1  Modelicax_0Requirements_Internal_SlidingWindow_init
  (double  T0_0, double  t00_0) {
  PushContext("Modelica_Requirements.Internal.SlidingWindow.init")
  {
    /* Declare outputs and temporaries */
    struct DymStruc1  buffer0_0;
    MarkObject retmark_ = PushMark();
    {
      struct DymStruc1 dummy_DymStruc1;
      dummy_DymStruc1 = Modelicax_0Requirements_Internal_SlidingWindow_Buffer(
        T0_0, t00_0, RealConvertInteger (IntegerFill( 0, 1, (SizeType)(20))), 
        IntegerFill( false, 1, (SizeType)(20)), 0, 0, 0);
      PushMark();
      buffer0_0.T_0member=0;
      buffer0_0.T_0member = dummy_DymStruc1.T_0member;
      buffer0_0.t0_0member=0;
      buffer0_0.t0_0member = dummy_DymStruc1.t0_0member;
      buffer0_0.first_0member=0;
      buffer0_0.first_0member = dummy_DymStruc1.first_0member;
      buffer0_0.last_0member=0;
      buffer0_0.last_0member = dummy_DymStruc1.last_0member;
      buffer0_0.nElem_0member=0;
      buffer0_0.nElem_0member = dummy_DymStruc1.nElem_0member;
      buffer0_0.t_0member=RealTemporary( 1, 20);
      RePushMark(&retmark_);
      RealFillAssign( buffer0_0.t_0member, 0);
      RealAssign (buffer0_0.t_0member, dummy_DymStruc1.t_0member);
      buffer0_0.b_0member=IntegerTemporary( 1, 20);
      RePushMark(&retmark_);
      IntegerFillAssign( buffer0_0.b_0member, 0);
      IntegerAssign (buffer0_0.b_0member, dummy_DymStruc1.b_0member);
    }
    Release();
    /* Start of real code */
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return buffer0_0;
  }}

/* Flattened Modelica model:

function Modelica_Requirements.Internal.SlidingWindow.maxDuration
discrete input Modelica_Requirements.Internal.SlidingWindow.Buffer buffer;
discrete input Real t(unit = "s") "Actual time instant";
input Boolean b(start = false) "Actual value at t (used if no element is in the buffer)";
discrete output Real duration(unit = "s") "Maximum duration where buffer value is true in window";
protected 
discrete Real T(start = buffer.T, unit = "s");
discrete Real t1(unit = "s");
discrete Real t2(unit = "s");
Integer nElem(start = buffer.nElem);
Integer iStart;
public 
algorithm 
if (nElem < 1) then 
duration := (if b then min(T, t-buffer.t0) else 0);
return;
end if;
if (Modelica_Requirements.Internal.SlidingWindow.firstValue(
buffer)) then 
t1 := Modelica_Requirements.Internal.SlidingWindow.indexTime(
buffer, 
1);
duration := max(0, min(t-t1, T));
iStart := 3;
else
duration := 0;
iStart := 2;
end if;
for i in (iStart:2:nElem) loop
assert( not Modelica_Requirements.Internal.SlidingWindow.indexValue(
buffer, 
i-1) and Modelica_Requirements.Internal.SlidingWindow.indexValue(
buffer, 
i), "Values in buffer not correct");
t1 := Modelica_Requirements.Internal.SlidingWindow.indexTime(
buffer, 
i-1);
t2 := Modelica_Requirements.Internal.SlidingWindow.indexTime(
buffer, 
i);
if (t1 <= t-T) then 
return;
end if;
if (t2 > t-T) then 
duration := max(duration, t1-t2);
else
duration := max(duration, t1-(t-T));
return;
end if;
end for;
if ( not Modelica_Requirements.Internal.SlidingWindow.lastValue(
buffer)) then 
t1 := Modelica_Requirements.Internal.SlidingWindow.indexTime(
buffer, 
nElem);
t2 := max(buffer.t0, t-T);
if (t1 > t2) then 
duration := max(duration, t1-t2);
end if;
end if;
end Modelica_Requirements.Internal.SlidingWindow.maxDuration;

  */
DYMOLA_STATIC double   Modelicax_0Requirements_Internal_SlidingWindow_maxDuration
  (struct DymStruc1 buffer0_0, double  t0_0, int  b0_0) {
  PushContext("Modelica_Requirements.Internal.SlidingWindow.maxDuration")
  {
    /* Declare outputs and temporaries */
    double   duration0_0;
    double   T0_0;
    double   t10_0;
    double   t20_0;
    int   nElem0_0;
    int   iStart0_0;
    MarkObject retmark_ = PushMark();
    duration0_0=0;
    T0_0 = buffer0_0.T_0member;
    t10_0=0;
    t20_0=0;
    nElem0_0 = buffer0_0.nElem_0member;
    iStart0_0=0;
    /* Start of real code */
      if (nElem0_0 < 1) {
        duration0_0 = IF b0_0 THEN RealBmin(T0_0, t0_0-buffer0_0.t0_0member)
           ELSE 0;
        goto returnTag;
      }
      if (Modelicax_0Requirements_Internal_SlidingWindow_firstValue(buffer0_0))
         {
        t10_0 = Modelicax_0Requirements_Internal_SlidingWindow_indexTime(
          buffer0_0, 1);
        duration0_0 = RealBmax(0, RealBmin(t0_0-t10_0, T0_0));
        iStart0_0 = 3;
      }
      else{
        duration0_0 = 0;
        iStart0_0 = 2;
      }
      {
        int start_ = iStart0_0;
        int end_ = nElem0_0;
        int i0_0_0;
        for(i0_0_0 = start_;(i0_0_0 - end_) * 2 <= 0 ;i0_0_0 += 2) {
          AssertModelica( NOT Modelicax_0Requirements_Internal_SlidingWindow_indexValue
            (buffer0_0, i0_0_0-1) AND Modelicax_0Requirements_Internal_SlidingWindow_indexValue
            (buffer0_0, i0_0_0)," not Modelica_Requirements.Internal.SlidingWindow.indexValue(\nbuffer, \ni-1) and Modelica_Requirements.Internal.SlidingWindow.indexValue(\nbuffer, \ni)",
             "Values in buffer not correct");
          t10_0 = Modelicax_0Requirements_Internal_SlidingWindow_indexTime(
            buffer0_0, i0_0_0-1);
          t20_0 = Modelicax_0Requirements_Internal_SlidingWindow_indexTime(
            buffer0_0, i0_0_0);
          if (t10_0 <= t0_0-T0_0) {
            goto returnTag;
          }
          if (t20_0 > t0_0-T0_0) {
            duration0_0 = RealBmax(duration0_0, t10_0-t20_0);
          }
          else{
            duration0_0 = RealBmax(duration0_0, t10_0-(t0_0-T0_0));
            goto returnTag;
          }
        }
      }
      if ( NOT Modelicax_0Requirements_Internal_SlidingWindow_lastValue(
        buffer0_0)) {
        t10_0 = Modelicax_0Requirements_Internal_SlidingWindow_indexTime(
          buffer0_0, nElem0_0);
        t20_0 = RealBmax(buffer0_0.t0_0member, t0_0-T0_0);
        if (t10_0 > t20_0) {
          duration0_0 = RealBmax(duration0_0, t10_0-t20_0);
        }
      }
    returnTag:
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return duration0_0;
  }}

/* Flattened Modelica model:

function Modelica_Requirements.Internal.SlidingWindow.push
discrete input Modelica_Requirements.Internal.SlidingWindow.Buffer buffer;
discrete input Real t "Time instant of v to be stored in buffer";
input Boolean b(start = false) "Value b at time instant t to be stored in buffer";
discrete output Modelica_Requirements.Internal.SlidingWindow.Buffer newBuffer;
protected 
constant Real eps = 1E-12;
discrete Real tOld(start = t-(1-eps)*buffer.T, unit = "s");
Integer first(start = buffer.first);
Integer last(start = buffer.last);
Integer nElem(start = buffer.nElem);
Boolean finished(start = false);
Integer i(start = 0);
public 
algorithm 
if (nElem > 0) then 
if (last > first) then 
i := last;
while i <= 20 loop
if (buffer.t[i] <= tOld) then 
i := i+1;
nElem := nElem-1;
else
finished := true;
break;
end if;
end while;
last := (if i > 20 then 1 else i);
end if;
if ( not finished) then 
i := last;
while i <= first loop
if (buffer.t[i] <= tOld) then 
i := i+1;
nElem := nElem-1;
else
break;
end if;
end while;
end if;
if (nElem > 0) then 
last := i;
else
first := 0;
last := 0;
end if;
end if;
if (nElem >= 20) then 
ModelicaInternal_print("... warning: buffer of sliding window too small at time = "+       String(t, true, 0)+" s (results will be for smaller sliding time window)", "");
end if;
newBuffer := buffer;
if (nElem > 0) then 
first := (if first+1 <= 20 then first+1 else 1);
else
first := 1;
last := 1;
end if;
nElem := nElem+1;
newBuffer.first := first;
newBuffer.last := last;
newBuffer.nElem := nElem;
newBuffer.t[first] := t;
newBuffer.b[first] := b;
end Modelica_Requirements.Internal.SlidingWindow.push;

  */
DYMOLA_STATIC struct DymStruc1  Modelicax_0Requirements_Internal_SlidingWindow_push
  (struct DymStruc1 buffer0_0, double  t0_0, int  b0_0) {
  char*retSMark_=GetStringMark();
  PushContext("Modelica_Requirements.Internal.SlidingWindow.push")
  {
    /* Declare outputs and temporaries */
    struct DymStruc1  newBuffer0_0;
    double   eps0_0;
    double   tOld0_0;
    int   first0_0;
    int   last0_0;
    int   nElem0_0;
    int   finished0_0;
    int   i0_0;
    MarkObject retmark_ = PushMark();
    newBuffer0_0.T_0member=0;
    newBuffer0_0.t0_0member=0;
    newBuffer0_0.t_0member=RealTemporary( 1, 20);
    RePushMark(&retmark_);
    RealFillAssign( newBuffer0_0.t_0member, 0);
    newBuffer0_0.b_0member=IntegerTemporary( 1, 20);
    RePushMark(&retmark_);
    IntegerFillAssign( newBuffer0_0.b_0member, 0);
    newBuffer0_0.first_0member=0;
    newBuffer0_0.last_0member=0;
    newBuffer0_0.nElem_0member=0;
    eps0_0 = 1E-12;
    tOld0_0 = t0_0-(1-eps0_0)*buffer0_0.T_0member;
    first0_0 = buffer0_0.first_0member;
    last0_0 = buffer0_0.last_0member;
    nElem0_0 = buffer0_0.nElem_0member;
    finished0_0 = false;
    i0_0 = 0;
    /* Start of real code */
      if (nElem0_0 > 0) {
        if (last0_0 > first0_0) {
          i0_0 = last0_0;
          while (i0_0 <= 20) {
            if (RealElement( buffer0_0.t_0member, (SizeType)(i0_0)) <= tOld0_0)
               {
              i0_0 = i0_0+1;
              nElem0_0 = nElem0_0-1;
            }
            else{
              finished0_0 = true;
              break;
            }
          }
          last0_0 = IF i0_0 > 20 THEN 1 ELSE i0_0;
        }
        if ( NOT finished0_0) {
          i0_0 = last0_0;
          while (i0_0 <= first0_0) {
            if (RealElement( buffer0_0.t_0member, (SizeType)(i0_0)) <= tOld0_0)
               {
              i0_0 = i0_0+1;
              nElem0_0 = nElem0_0-1;
            }
            else{
              break;
            }
          }
        }
        if (nElem0_0 > 0) {
          last0_0 = i0_0;
        }
        else{
          first0_0 = 0;
          last0_0 = 0;
        }
      }
      if (nElem0_0 >= 20) {
        ModelicaInternal_print(StringAdd(StringAdd("... warning: buffer of sliding window too small at time = ",
          Real2String2(t0_0, true, 0))," s (results will be for smaller sliding time window)"),
           "");
      }
      newBuffer0_0.T_0member = buffer0_0.T_0member;
      IntegerAssign (newBuffer0_0.b_0member, buffer0_0.b_0member);
      newBuffer0_0.first_0member = buffer0_0.first_0member;
      newBuffer0_0.last_0member = buffer0_0.last_0member;
      newBuffer0_0.nElem_0member = buffer0_0.nElem_0member;
      RealAssign (newBuffer0_0.t_0member, buffer0_0.t_0member);
      newBuffer0_0.t0_0member = buffer0_0.t0_0member;
      Release();
      if (nElem0_0 > 0) {
        first0_0 = IF first0_0+1 <= 20 THEN first0_0+1 ELSE 1;
      }
      else{
        first0_0 = 1;
        last0_0 = 1;
      }
      nElem0_0 = nElem0_0+1;
      newBuffer0_0.first_0member = first0_0;
      newBuffer0_0.last_0member = last0_0;
      newBuffer0_0.nElem_0member = nElem0_0;
      SetRealElement(t0_0, newBuffer0_0.t_0member, (SizeType)(first0_0));
      SetIntegerElement(b0_0, newBuffer0_0.b_0member, (SizeType)(first0_0));
    /* Output section */
    PopMark(retmark_);
    SetStringMark(retSMark_);
    PopContext()
    return newBuffer0_0;
  }}

/* Flattened Modelica model:

function Modelica_Requirements.Internal.SlidingWindow.Buffer
discrete input Real T(unit = "s") "Length of sliding window";
discrete input Real t0(unit = "s") "Time instant where sliding time window starts";
discrete input Real t[20](unit = "s") "Time instants";
input Boolean b[20] "Values at corresponding time instants";
input Integer first "Index of first element in buffer";
input Integer last "Index of last element in buffer";
input Integer nElem "Number of elements in the buffer";
discrete output Modelica_Requirements.Internal.SlidingWindow.Buffer _out(start = Modelica_Requirements.Internal.SlidingWindow.Buffer(
T = T, 
t0 = t0, 
t = t, 
b = b, 
first = first, 
last = last, 
nElem = nElem
));

algorithm 
end Modelica_Requirements.Internal.SlidingWindow.Buffer;

  */
DYMOLA_STATIC struct DymStruc1  Modelicax_0Requirements_Internal_SlidingWindow_Buffer
  (double  T0_0, double  t00_0, RealArray   t0_0, IntegerArray   b0_0, int  
  first0_0, int  last0_0, int  nElem0_0) {
  PushContext("Modelica_Requirements.Internal.SlidingWindow.Buffer")
  AssertModelica(DYNSizeSimple(t0_0,1)==20,"size(t, 1) == 20","Dimension check of input to function failed");
  AssertModelica(DYNSizeSimple(b0_0,1)==20,"size(b, 1) == 20","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    struct DymStruc1  x_0out;
    MarkObject retmark_ = PushMark();
    x_0out.T_0member = T0_0;
    x_0out.t0_0member = t00_0;
    x_0out.t_0member=RealTemporary( 1, 20);
    RePushMark(&retmark_);
    RealAssign (x_0out.t_0member, t0_0);
    Release();
    x_0out.b_0member=IntegerTemporary( 1, 20);
    RePushMark(&retmark_);
    IntegerAssign (x_0out.b_0member, b0_0);
    Release();
    x_0out.first_0member = first0_0;
    x_0out.last_0member = last0_0;
    x_0out.nElem_0member = nElem0_0;
    /* Start of real code */
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return x_0out;
  }}

/* Flattened Modelica model:

function Modelica_Requirements.Internal.SlidingWindow.firstValue
discrete input Modelica_Requirements.Internal.SlidingWindow.Buffer buffer;
output Boolean b "Newest value";

algorithm 
assert(buffer.nElem > 0, "No value in buffer");
b := buffer.b[buffer.first];
end Modelica_Requirements.Internal.SlidingWindow.firstValue;

  */
DYMOLA_STATIC int   Modelicax_0Requirements_Internal_SlidingWindow_firstValue(
  struct DymStruc1 buffer0_0) {
  PushContext("Modelica_Requirements.Internal.SlidingWindow.firstValue")
  {
    /* Declare outputs and temporaries */
    int   b0_0;
    b0_0=0;
    /* Start of real code */
      AssertModelica(buffer0_0.nElem_0member > 0,"buffer.nElem > 0", 
        "No value in buffer");
      b0_0 = IntegerElement( buffer0_0.b_0member, (SizeType)(buffer0_0.
        first_0member));
    /* Output section */
    PopContext()
    return b0_0;
  }}

/* Flattened Modelica model:

function Modelica_Requirements.Internal.SlidingWindow.indexTime
discrete input Modelica_Requirements.Internal.SlidingWindow.Buffer buffer;
input Integer index(min = 1.0) "Index of time value (index >= 1; index=1: first)";
discrete output Real t(unit = "s") "Time value at index of buffer";
protected 
Integer first(start = buffer.first);
Integer nElem(start = buffer.nElem);
public 
algorithm 
assert(index >= 1 and index <= nElem, "Index not in range 1 ... buffer.nElem");
if (first >= index) then 
t := buffer.t[first-index+1];
else
t := buffer.t[20-(index-first)+1];
end if;
end Modelica_Requirements.Internal.SlidingWindow.indexTime;

  */
DYMOLA_STATIC double   Modelicax_0Requirements_Internal_SlidingWindow_indexTime(
  struct DymStruc1 buffer0_0, int  index0_0) {
  PushContext("Modelica_Requirements.Internal.SlidingWindow.indexTime")
  {
    /* Declare outputs and temporaries */
    double   t0_0;
    int   first0_0;
    int   nElem0_0;
    t0_0=0;
    first0_0 = buffer0_0.first_0member;
    nElem0_0 = buffer0_0.nElem_0member;
    /* Start of real code */
      AssertModelica(index0_0 >= 1 AND index0_0 <= nElem0_0,"index >= 1 and index <= nElem",
         "Index not in range 1 ... buffer.nElem");
      if (first0_0 >= index0_0) {
        t0_0 = RealElement( buffer0_0.t_0member, (SizeType)(first0_0-index0_0+1));
      }
      else{
        t0_0 = RealElement( buffer0_0.t_0member, (SizeType)(20-(index0_0-
          first0_0)+1));
      }
    /* Output section */
    PopContext()
    return t0_0;
  }}

/* Flattened Modelica model:

function Modelica_Requirements.Internal.SlidingWindow.indexValue
discrete input Modelica_Requirements.Internal.SlidingWindow.Buffer buffer;
input Integer index(min = 1.0) "Index of time value (index >= 1; index=1: first)";
output Boolean b "Value at buffer index";
protected 
Integer first(start = buffer.first);
Integer nElem(start = buffer.nElem);
public 
algorithm 
assert(index >= 1 and index <= nElem, "Index not in range 1 ... buffer.nElem");
if (first >= index) then 
b := buffer.b[first-index+1];
else
b := buffer.b[20-(index-first)+1];
end if;
end Modelica_Requirements.Internal.SlidingWindow.indexValue;

  */
DYMOLA_STATIC int   Modelicax_0Requirements_Internal_SlidingWindow_indexValue(
  struct DymStruc1 buffer0_0, int  index0_0) {
  PushContext("Modelica_Requirements.Internal.SlidingWindow.indexValue")
  {
    /* Declare outputs and temporaries */
    int   b0_0;
    int   first0_0;
    int   nElem0_0;
    b0_0=0;
    first0_0 = buffer0_0.first_0member;
    nElem0_0 = buffer0_0.nElem_0member;
    /* Start of real code */
      AssertModelica(index0_0 >= 1 AND index0_0 <= nElem0_0,"index >= 1 and index <= nElem",
         "Index not in range 1 ... buffer.nElem");
      if (first0_0 >= index0_0) {
        b0_0 = IntegerElement( buffer0_0.b_0member, (SizeType)(first0_0-index0_0
          +1));
      }
      else{
        b0_0 = IntegerElement( buffer0_0.b_0member, (SizeType)(20-(index0_0-
          first0_0)+1));
      }
    /* Output section */
    PopContext()
    return b0_0;
  }}

/* Flattened Modelica model:

function Modelica_Requirements.Internal.SlidingWindow.lastValue
discrete input Modelica_Requirements.Internal.SlidingWindow.Buffer buffer;
output Boolean b "Newest value";

algorithm 
assert(buffer.nElem > 0, "No value in buffer");
b := buffer.b[buffer.last];
end Modelica_Requirements.Internal.SlidingWindow.lastValue;

  */
DYMOLA_STATIC int   Modelicax_0Requirements_Internal_SlidingWindow_lastValue(
  struct DymStruc1 buffer0_0) {
  PushContext("Modelica_Requirements.Internal.SlidingWindow.lastValue")
  {
    /* Declare outputs and temporaries */
    int   b0_0;
    b0_0=0;
    /* Start of real code */
      AssertModelica(buffer0_0.nElem_0member > 0,"buffer.nElem > 0", 
        "No value in buffer");
      b0_0 = IntegerElement( buffer0_0.b_0member, (SizeType)(buffer0_0.
        last_0member));
    /* Output section */
    PopContext()
    return b0_0;
  }}
/* DSblock C-code: */

#define NX_    0
#define NX2_   0
#define NU_    0
#define NY_    0
#define NW_    97
#define NWP_   44
#define NP_    22
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   0
#define MAXAuxStr_   2
#define MAXAuxStrLen_   500
#define NHash1_ 1895277178
#define NHash2_ 1509302875
#define NHash3_ 0
#define NI_    0
#define NRelF_ 2
#define NRel_  4
#define NTim_  2
#define NSamp_ 0
#define NCons_ 0
#define NA_    3
#define SizePre_ 48
#define SizeEq_ 0
#define SizeDelay_ 0
#define QNLmax_ 0
#define MAXAux 49
#define NrDymolaTimers_ 0
#define NWhen_ 4
#define NCheckIf_ 0
#define NGlobalHelp_ 3
#define NGlobalHelpI_ 0
#ifndef NExternalObject_
#define NExternalObject_ 1
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="Modelica_Requirements.Examples.Elementary.ChecksInSlidingWindow.BandDuration";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "C:/Users/HubertusTummescheit/AppData/Roaming/DassaultSystemes/Dymola/dymola.lic";
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations
InitialSection
#if defined(DynSimStruct)
DYNX(W_,44) = 0;
DYNX(W_,45) = 0;
DYNX(W_,46) = false;
#endif

InitialSection
#if defined(DynSimStruct)
DYNX(W_,1) = 1;
DYNX(W_,42) = 12;
#endif
DYNSetAuxString(did_, "NoName", 0);
DYNSetAuxString(did_, "NoName", 1);
#if defined(DynSimStruct)
DYNX(W_,29) = 2;
DYNX(W_,30) = 3;
DYNX(W_,32) = 1;
DYNX(W_,0) = 1;
DYNX(W_,2) = false;
DYNX(W_,35) = false;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
AssertModelica(DYNX(DP_,20) < DYNX(DP_,21),"bandDuration.lowerLimit < bandDuration.upperLimit",
   "lowerLimit < upperLimit required");
AssertModelica(DYNX(DP_,21) < DYNX(DP_,19),"bandDuration.upperLimit < bandDuration.window",
   "upperLimit < window required");
BoundParameterSection
DYNX(W_,3) = DYNX(DP_,0);
DYNX(W_,4) = IF DYNX(DP_,12) THEN 1.0 ELSE 0.0;
DYNX(W_,5) = DYNX(DP_,0);
DYNX(W_,6) = IF DYNX(DP_,12) THEN 0.0 ELSE 1.0;
DYNX(W_,7) = DYNX(DP_,1);
DYNX(W_,8) = IF DYNX(DP_,12) THEN 1.0 ELSE 0.0;
DYNX(W_,9) = DYNX(DP_,2);
DYNX(W_,10) = IF DYNX(DP_,12) THEN 0.0 ELSE 1.0;
DYNX(W_,11) = DYNX(DP_,3);
DYNX(W_,12) = IF DYNX(DP_,12) THEN 1.0 ELSE 0.0;
DYNX(W_,13) = DYNX(DP_,4);
DYNX(W_,14) = IF DYNX(DP_,12) THEN 0.0 ELSE 1.0;
DYNX(W_,15) = DYNX(DP_,5);
DYNX(W_,16) = IF DYNX(DP_,12) THEN 1.0 ELSE 0.0;
DYNX(W_,17) = DYNX(DP_,6);
DYNX(W_,18) = IF DYNX(DP_,12) THEN 0.0 ELSE 1.0;
DYNX(W_,19) = DYNX(DP_,7);
DYNX(W_,20) = IF DYNX(DP_,12) THEN 1.0 ELSE 0.0;
DYNX(W_,21) = DYNX(DP_,8);
DYNX(W_,22) = IF DYNX(DP_,12) THEN 0.0 ELSE 1.0;
DYNX(W_,23) = DYNX(DP_,9);
DYNX(W_,24) = IF DYNX(DP_,12) THEN 1.0 ELSE 0.0;
DYNX(W_,25) = DYNX(DP_,10);
DYNX(W_,26) = IF DYNX(DP_,12) THEN 0.0 ELSE 1.0;
DYNX(W_,27) = DYNX(DP_,11);
DYNX(W_,28) = IF DYNX(DP_,12) THEN 1.0 ELSE 0.0;
DYNX(W_,31) = DYNX(W_,0);
DYNX(W_,33) = DYNX(DP_,13);
DYNX(W_,34) = DYNX(DP_,14);
InitialBoundSection
DYNX(DYNhelp,0) = (PushModelContext(1,"Modelica.Utilities.Strings.isEmpty(check.combiTimeTable.fileName)")
  Modelica_Utilities_Strings_isEmpty("NoName"));
PopModelContext();
DYNX(DYNhelp,1) = divinvGuarded(DYNX(W_,32),"check.combiTimeTable.timeScale");
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTimeTable((if check.combiTimeTable.tableOnFile then check.combiTimeTable.tableName else \"NoName\"), (if check.combiTimeTable.tableOnFile and check.combiTimeTable.fileName <> \"NoName\" and  not Modelica.Utilities.Strings.isEmpty(check.combiTimeTable.fileName) then check.combiTimeTable.fileName else \"NoName\"), check.combiTimeTable.table, check.combiTimeTable.start...")
    Modelica_Blocks_Types_ExternalCombiTimeTable_M(IF DYNX(W_,2) THEN "NoName"
     ELSE "NoName", IF DYNX(W_,2) AND (strcmp("NoName", "NoName")!=0) AND  NOT 
    DYNX(DYNhelp,0) THEN "NoName" ELSE "NoName", RealTemporaryDense( &DYNX(W_,3),
     2, 13, 2), DYNX(DYNhelp,1)*DYNX(W_,33), IntegerTemporaryDense( &DYNX(W_,29),
     1, 1), (Integer)(DYNX(W_,30)), (Integer)(DYNX(W_,31)), DYNX(DYNhelp,1)*
    DYNX(W_,34), (Integer)(IF DYNX(W_,30) == 1 THEN DYNX(DP_,17) ELSE IF 
    DYNX(W_,30) == 3 THEN 1 ELSE 3), (Integer)(IF DYNX(W_,2) THEN DYNX(DP_,15)
     ELSE false), 0, 1));
  DYNX(W_,41) = dummy_DymStruc0.id_0member;
PopAllMarks();
}
BoundParameterSection
DYNX(W_,38) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getTimeTableTmin(\ncheck.combiTimeTable.tableID)")
  Modelica_Blocks_Tables_Internal_getTimeTableTmin_M(DymStruc0_construct(
  (Integer)(DYNX(W_,41)))));
PopModelContext();
DYNX(W_,36) = DYNX(W_,38)*DYNX(W_,32);
DYNX(W_,39) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getTimeTableTmax(\ncheck.combiTimeTable.tableID)")
  Modelica_Blocks_Tables_Internal_getTimeTableTmax_M(DymStruc0_construct(
  (Integer)(DYNX(W_,41)))));
PopModelContext();
DYNX(W_,37) = DYNX(W_,39)*DYNX(W_,32);
DYNX(W_,40) = DYNX(DP_,16);
InitialSection
InitialStartSection
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialBoundSection
DYNX(Aux_,0) = DYNX(W_,48);
DYNX(Aux_,22) = DYNX(W_,70);
DYNX(Aux_,23) = DYNX(W_,71);
DYNX(Aux_,24) = DYNX(W_,72);
DYNX(Aux_,25) = DYNX(W_,73);
DYNX(Aux_,26) = DYNX(W_,74);
DYNX(Aux_,27) = DYNX(W_,75);
DYNX(Aux_,28) = DYNX(W_,76);
DYNX(Aux_,29) = DYNX(W_,77);
DYNX(Aux_,30) = DYNX(W_,78);
DYNX(Aux_,31) = DYNX(W_,79);
DYNX(Aux_,32) = DYNX(W_,80);
DYNX(Aux_,33) = DYNX(W_,81);
DYNX(Aux_,34) = DYNX(W_,82);
DYNX(Aux_,35) = DYNX(W_,83);
DYNX(Aux_,36) = DYNX(W_,84);
DYNX(Aux_,37) = DYNX(W_,85);
DYNX(Aux_,38) = DYNX(W_,86);
DYNX(Aux_,39) = DYNX(W_,87);
DYNX(Aux_,40) = DYNX(W_,88);
DYNX(Aux_,41) = DYNX(W_,89);
DYNX(Aux_,42) = DYNX(W_,90);
DYNX(Aux_,43) = DYNX(W_,91);
DYNX(Aux_,44) = DYNX(W_,92);
DYNX(Aux_,2) = DYNX(W_,50);
DYNX(Aux_,3) = DYNX(W_,51);
DYNX(Aux_,4) = DYNX(W_,52);
DYNX(Aux_,5) = DYNX(W_,53);
DYNX(Aux_,6) = DYNX(W_,54);
DYNX(Aux_,7) = DYNX(W_,55);
DYNX(Aux_,8) = DYNX(W_,56);
DYNX(Aux_,9) = DYNX(W_,57);
DYNX(Aux_,10) = DYNX(W_,58);
DYNX(Aux_,11) = DYNX(W_,59);
DYNX(Aux_,12) = DYNX(W_,60);
DYNX(Aux_,13) = DYNX(W_,61);
DYNX(Aux_,14) = DYNX(W_,62);
DYNX(Aux_,15) = DYNX(W_,63);
DYNX(Aux_,16) = DYNX(W_,64);
DYNX(Aux_,17) = DYNX(W_,65);
DYNX(Aux_,18) = DYNX(W_,66);
DYNX(Aux_,19) = DYNX(W_,67);
DYNX(Aux_,20) = DYNX(W_,68);
DYNX(Aux_,21) = DYNX(W_,69);
DYNX(Aux_,1) = DYNX(W_,49);
DYNX(Aux_,45) = DYNX(W_,46);
DYNX(Aux_,46) = DYNX(W_,93);
DYNX(Aux_,48) = DYNX(W_,45);
DYNX(Aux_,47) = DYNX(W_,44);
InitialSection
InitialSection2
DYNX(W_,93) = true;
InitialBoundSection
DYNX(Aux_,46) = true;
InitialSection2
DYNX(W_,95) = DYNTime;
InitialBoundSection
DYNX(W_,45) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getNextTimeEvent(\ncheck.combiTimeTable.tableID, \ncheck.combiTimeTable.timeScaled)")
  Modelica_Blocks_Tables_Internal_getNextTimeEvent_M(DymStruc0_construct(
  (Integer)(DYNX(W_,41))), DYNX(W_,95)));
PopModelContext();
InitialSection2
DYNX(W_,44) = IF Less(DYNX(W_,45),"check.combiTimeTable.nextTimeEventScaled", 
  1E+60,"1E+60", 0) THEN DYNX(W_,45) ELSE 1E+60;
DYNX(W_,94) = DYNX(W_,40)+(PushModelContext(1,"Modelica.Blocks.Tables.Internal.getTimeTableValueNoDer(\ncheck.combiTimeTable.tableID, \n1, \ncheck.combiTimeTable.timeScaled, \ncheck.combiTimeTable.nextTimeEventScaled, \ncheck.combiTimeTable.nextTimeEventScaled_.start)")
  Modelica_Blocks_Tables_Internal_getTimeTableValueNoDer_M(DymStruc0_construct(
  (Integer)(DYNX(W_,41))), 1, DYNX(W_,95), DYNX(W_,45), DYNX(Aux_,48)));
PopModelContext();
DYNX(W_,46) = GreaterEqual(DYNX(W_,94),"check.realToBoolean.u", DYNX(DP_,18),
  "check.realToBoolean.threshold", 1);
{
  struct DymStruc1 dummy_DymStruc1;
  dummy_DymStruc1 = (PushModelContext(1,"Modelica_Requirements.Internal.SlidingWindow.push(\nModelica_Requirements.Internal.SlidingWindow.init(bandDuration.window, time), \ntime, \nbandDuration.check)")
    Modelicax_0Requirements_Internal_SlidingWindow_push(Modelicax_0Requirements_Internal_SlidingWindow_init
    (DYNX(DP_,19), DYNTime), DYNTime, (Integer)(DYNX(W_,46))));
  DYNX(W_,48) = dummy_DymStruc1.T_0member;
  RealAssign (RealTemporaryDense( &DYNX(W_,70), 1, 20), RealConvertInteger (
    dummy_DymStruc1.b_0member));
  DYNX(W_,90) = dummy_DymStruc1.first_0member;
  DYNX(W_,91) = dummy_DymStruc1.last_0member;
  DYNX(W_,92) = dummy_DymStruc1.nElem_0member;
  RealAssign (RealTemporaryDense( &DYNX(W_,50), 1, 20), dummy_DymStruc1.t_0member);
  DYNX(W_,49) = dummy_DymStruc1.t0_0member;
PopAllMarks();
}
DYNX(W_,43) = DYNTime+DYNX(DP_,19);
InitialBoundSection
DYNX(Aux_,0) = DYNX(W_,48);
DYNX(Aux_,2) = DYNX(W_,50);
DYNX(Aux_,3) = DYNX(W_,51);
DYNX(Aux_,4) = DYNX(W_,52);
DYNX(Aux_,5) = DYNX(W_,53);
DYNX(Aux_,6) = DYNX(W_,54);
DYNX(Aux_,7) = DYNX(W_,55);
DYNX(Aux_,8) = DYNX(W_,56);
DYNX(Aux_,9) = DYNX(W_,57);
DYNX(Aux_,10) = DYNX(W_,58);
DYNX(Aux_,11) = DYNX(W_,59);
DYNX(Aux_,12) = DYNX(W_,60);
DYNX(Aux_,13) = DYNX(W_,61);
DYNX(Aux_,14) = DYNX(W_,62);
DYNX(Aux_,15) = DYNX(W_,63);
DYNX(Aux_,16) = DYNX(W_,64);
DYNX(Aux_,17) = DYNX(W_,65);
DYNX(Aux_,18) = DYNX(W_,66);
DYNX(Aux_,19) = DYNX(W_,67);
DYNX(Aux_,20) = DYNX(W_,68);
DYNX(Aux_,21) = DYNX(W_,69);
DYNX(Aux_,1) = DYNX(W_,49);
DYNX(Aux_,42) = DYNX(W_,90);
DYNX(Aux_,43) = DYNX(W_,91);
DYNX(Aux_,44) = DYNX(W_,92);
DYNX(Aux_,22) = DYNX(W_,70);
DYNX(Aux_,23) = DYNX(W_,71);
DYNX(Aux_,24) = DYNX(W_,72);
DYNX(Aux_,25) = DYNX(W_,73);
DYNX(Aux_,26) = DYNX(W_,74);
DYNX(Aux_,27) = DYNX(W_,75);
DYNX(Aux_,28) = DYNX(W_,76);
DYNX(Aux_,29) = DYNX(W_,77);
DYNX(Aux_,30) = DYNX(W_,78);
DYNX(Aux_,31) = DYNX(W_,79);
DYNX(Aux_,32) = DYNX(W_,80);
DYNX(Aux_,33) = DYNX(W_,81);
DYNX(Aux_,34) = DYNX(W_,82);
DYNX(Aux_,35) = DYNX(W_,83);
DYNX(Aux_,36) = DYNX(W_,84);
DYNX(Aux_,37) = DYNX(W_,85);
DYNX(Aux_,38) = DYNX(W_,86);
DYNX(Aux_,39) = DYNX(W_,87);
DYNX(Aux_,40) = DYNX(W_,88);
DYNX(Aux_,41) = DYNX(W_,89);
DYNX(Aux_,45) = DYNX(W_,46);
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
InitialSection2
  (PushModelContext(1,"Modelica.Blocks.Sources.BooleanTable.isValidTable(check.table)")
    Modelica_Blocks_Sources_BooleanTable_isValidTable(RealTemporaryDense( 
    &DYNX(DP_,0), 1, 12)));
  PopAllMarks();
EndInitialSection

OutputSection

DynamicsSection

AcceptedSection1

AcceptedSection2
DYNX(W_,95) = DYNTime;
beginwhenBlock
whenModelica(GreaterEqualTimeMinor(PRE(DYNX(W_,44), 0), 0), 0) 
  DYNX(W_,45) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getNextTimeEvent(\ncheck.combiTimeTable.tableID, \ncheck.combiTimeTable.timeScaled)")
    Modelica_Blocks_Tables_Internal_getNextTimeEvent_M(DymStruc0_construct(
    (Integer)(DYNX(W_,41))), DYNX(W_,95)));
  PopModelContext();
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelica(GreaterEqualTimeMinor(PRE(DYNX(W_,44), 0), 0), 1) 
  DYNX(W_,44) = IF Less(DYNX(W_,45),"check.combiTimeTable.nextTimeEventScaled", 
    1E+60,"1E+60", 0) THEN DYNX(W_,45) ELSE 1E+60;
endwhenModelica()
endwhenBlock


DYNX(DYNhelp,2) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getTimeTableValueNoDer(\ncheck.combiTimeTable.tableID, \n1, \ncheck.combiTimeTable.timeScaled, \ncheck.combiTimeTable.nextTimeEventScaled, \npre(check.combiTimeTable.nextTimeEventScaled))")
  Modelica_Blocks_Tables_Internal_getTimeTableValueNoDer_M(DymStruc0_construct(
  (Integer)(DYNX(W_,41))), 1, DYNX(W_,95), DYNX(W_,45), PRE(DYNX(W_,45), 1)));
PopModelContext();
DYNX(W_,94) = DYNX(W_,40)+DYNX(DYNhelp,2);
DYNX(W_,46) = GreaterEqual(DYNX(W_,94),"check.realToBoolean.u", DYNX(DP_,18),
  "check.realToBoolean.threshold", 1);
beginwhenBlock
whenModelica(( DYNX(W_,46) != PRE(DYNX(W_,46), 2) ), 2) 
  {
    struct DymStruc1 dummy_DymStruc1;
    dummy_DymStruc1 = (PushModelContext(1,"Modelica_Requirements.Internal.SlidingWindow.push(\npre(bandDuration.buffer), \ntime, \nbandDuration.check)")
      Modelicax_0Requirements_Internal_SlidingWindow_push(DymStruc1_construct(
      PRE(DYNX(W_,48), 3), IntegerScalarArray ( 20, (int )(PRE(DYNX(W_,70), 4)),
       (int )(PRE(DYNX(W_,71), 5)), (int )(PRE(DYNX(W_,72), 6)), (int )(PRE(
      DYNX(W_,73), 7)), (int )(PRE(DYNX(W_,74), 8)), (int )(PRE(DYNX(W_,75), 9)),
       (int )(PRE(DYNX(W_,76), 10)), (int )(PRE(DYNX(W_,77), 11)), (int )(PRE(
      DYNX(W_,78), 12)), (int )(PRE(DYNX(W_,79), 13)), (int )(PRE(DYNX(W_,80), 14)),
       (int )(PRE(DYNX(W_,81), 15)), (int )(PRE(DYNX(W_,82), 16)), (int )(PRE(
      DYNX(W_,83), 17)), (int )(PRE(DYNX(W_,84), 18)), (int )(PRE(DYNX(W_,85), 19)),
       (int )(PRE(DYNX(W_,86), 20)), (int )(PRE(DYNX(W_,87), 21)), (int )(PRE(
      DYNX(W_,88), 22)), (int )(PRE(DYNX(W_,89), 23))), PRE(DYNX(W_,90), 24), 
      PRE(DYNX(W_,91), 25), PRE(DYNX(W_,92), 26), RealScalarArray ( 20, PRE(
      DYNX(W_,50), 27), PRE(DYNX(W_,51), 28), PRE(DYNX(W_,52), 29), PRE(
      DYNX(W_,53), 30), PRE(DYNX(W_,54), 31), PRE(DYNX(W_,55), 32), PRE(
      DYNX(W_,56), 33), PRE(DYNX(W_,57), 34), PRE(DYNX(W_,58), 35), PRE(
      DYNX(W_,59), 36), PRE(DYNX(W_,60), 37), PRE(DYNX(W_,61), 38), PRE(
      DYNX(W_,62), 39), PRE(DYNX(W_,63), 40), PRE(DYNX(W_,64), 41), PRE(
      DYNX(W_,65), 42), PRE(DYNX(W_,66), 43), PRE(DYNX(W_,67), 44), PRE(
      DYNX(W_,68), 45), PRE(DYNX(W_,69), 46)), PRE(DYNX(W_,49), 47)), DYNTime, 
      (Integer)(DYNX(W_,46))));
    DYNX(W_,48) = dummy_DymStruc1.T_0member;
    RealAssign (RealTemporaryDense( &DYNX(W_,70), 1, 20), RealConvertInteger (
      dummy_DymStruc1.b_0member));
    DYNX(W_,90) = dummy_DymStruc1.first_0member;
    DYNX(W_,91) = dummy_DymStruc1.last_0member;
    DYNX(W_,92) = dummy_DymStruc1.nElem_0member;
    RealAssign (RealTemporaryDense( &DYNX(W_,50), 1, 20), dummy_DymStruc1.t_0member);
    DYNX(W_,49) = dummy_DymStruc1.t0_0member;
  PopAllMarks();
  }
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelica(GreaterEqualTimeMinor(DYNX(W_,43), 1), 3) 
  DYNX(W_,93) = false;
endwhenModelica()
endwhenBlock


DYNX(W_,96) = (PushModelContext(1,"Modelica_Requirements.Internal.SlidingWindow.maxDuration(\nbandDuration.buffer, \ntime, \nbandDuration.check)")
  Modelicax_0Requirements_Internal_SlidingWindow_maxDuration(DymStruc1_construct(
  DYNX(W_,48), IntegerTemporaryDense( &DYNX(W_,70), 1, 20), (Integer)(
  DYNX(W_,90)), (Integer)(DYNX(W_,91)), (Integer)(DYNX(W_,92)), RealTemporaryDense( 
  &DYNX(W_,50), 1, 20), DYNX(W_,49)), DYNTime, (Integer)(DYNX(W_,46))));
PopAllMarks();
DYNX(W_,47) = IF GreaterEqual(DYNX(W_,96),"bandDuration.maxDuration", 
  DYNX(DP_,20),"bandDuration.lowerLimit", 2) AND LessEqual(DYNX(W_,96),
  "bandDuration.maxDuration", DYNX(DP_,21),"bandDuration.upperLimit", 3) THEN 3
   ELSE IF DYNX(W_,93) AND LessEqual(DYNX(W_,96),"bandDuration.maxDuration", 
  DYNX(DP_,21),"bandDuration.upperLimit", 3) THEN 2 ELSE 1;

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareParameter("check.table[1]", "Vector of time points. At every time point, the output y gets its opposite value (e.g., table={0,1}) [s]",\
 0, 1.0, 0.0,0.0,0.0,0,560)
DeclareParameter("check.table[2]", "Vector of time points. At every time point, the output y gets its opposite value (e.g., table={0,1}) [s]",\
 1, 3.5, 0.0,0.0,0.0,0,560)
DeclareParameter("check.table[3]", "Vector of time points. At every time point, the output y gets its opposite value (e.g., table={0,1}) [s]",\
 2, 5.2, 0.0,0.0,0.0,0,560)
DeclareParameter("check.table[4]", "Vector of time points. At every time point, the output y gets its opposite value (e.g., table={0,1}) [s]",\
 3, 5.4, 0.0,0.0,0.0,0,560)
DeclareParameter("check.table[5]", "Vector of time points. At every time point, the output y gets its opposite value (e.g., table={0,1}) [s]",\
 4, 5.6, 0.0,0.0,0.0,0,560)
DeclareParameter("check.table[6]", "Vector of time points. At every time point, the output y gets its opposite value (e.g., table={0,1}) [s]",\
 5, 5.8, 0.0,0.0,0.0,0,560)
DeclareParameter("check.table[7]", "Vector of time points. At every time point, the output y gets its opposite value (e.g., table={0,1}) [s]",\
 6, 6.0, 0.0,0.0,0.0,0,560)
DeclareParameter("check.table[8]", "Vector of time points. At every time point, the output y gets its opposite value (e.g., table={0,1}) [s]",\
 7, 8.5, 0.0,0.0,0.0,0,560)
DeclareParameter("check.table[9]", "Vector of time points. At every time point, the output y gets its opposite value (e.g., table={0,1}) [s]",\
 8, 9.1, 0.0,0.0,0.0,0,560)
DeclareParameter("check.table[10]", "Vector of time points. At every time point, the output y gets its opposite value (e.g., table={0,1}) [s]",\
 9, 10.5, 0.0,0.0,0.0,0,560)
DeclareParameter("check.table[11]", "Vector of time points. At every time point, the output y gets its opposite value (e.g., table={0,1}) [s]",\
 10, 11.5, 0.0,0.0,0.0,0,560)
DeclareParameter("check.table[12]", "Vector of time points. At every time point, the output y gets its opposite value (e.g., table={0,1}) [s]",\
 11, 12.0, 0.0,0.0,0.0,0,560)
DeclareParameter("check.startValue", "Start value of y. At time = table[1], y changes to 'not startValue' [:#(type=Boolean)]",\
 12, false, 0.0,0.0,0.0,0,562)
DeclareVariable("check.extrapolation", "Extrapolation of data outside the definition range [:#(type=Modelica.Blocks.Types.Extrapolation)]",\
 0, 1, 1.0,4.0,0.0,0,517)
DeclareParameter("check.startTime", "Output = false for time < startTime [s]", 13,\
 -1E+60, 0.0,0.0,0.0,0,560)
DeclareParameter("check.shiftTime", "Shift time of table [s]", 14, 0, 0.0,0.0,\
0.0,0,560)
DeclareAlias2("check.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "bandDuration.check", 1, 5, 46, 65)
DeclareVariable("check.combiTimeTable.nout", "Number of outputs [:#(type=Integer)]",\
 1, 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("check.combiTimeTable.y[1]", "Connector of Real output signals",\
 94, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("check.combiTimeTable.tableOnFile", "= true, if table is defined on file or in function usertab [:#(type=Boolean)]",\
 2, false, 0.0,0.0,0.0,0,515)
DeclareVariable("check.combiTimeTable.table[1, 1]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 3, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("check.combiTimeTable.table[1, 2]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 4, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("check.combiTimeTable.table[2, 1]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 5, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("check.combiTimeTable.table[2, 2]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 6, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("check.combiTimeTable.table[3, 1]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 7, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("check.combiTimeTable.table[3, 2]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 8, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("check.combiTimeTable.table[4, 1]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 9, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("check.combiTimeTable.table[4, 2]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 10, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("check.combiTimeTable.table[5, 1]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 11, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("check.combiTimeTable.table[5, 2]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 12, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("check.combiTimeTable.table[6, 1]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 13, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("check.combiTimeTable.table[6, 2]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 14, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("check.combiTimeTable.table[7, 1]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 15, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("check.combiTimeTable.table[7, 2]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 16, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("check.combiTimeTable.table[8, 1]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 17, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("check.combiTimeTable.table[8, 2]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 18, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("check.combiTimeTable.table[9, 1]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 19, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("check.combiTimeTable.table[9, 2]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 20, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("check.combiTimeTable.table[10, 1]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 21, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("check.combiTimeTable.table[10, 2]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 22, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("check.combiTimeTable.table[11, 1]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 23, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("check.combiTimeTable.table[11, 2]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 24, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("check.combiTimeTable.table[12, 1]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 25, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("check.combiTimeTable.table[12, 2]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 26, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("check.combiTimeTable.table[13, 1]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 27, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("check.combiTimeTable.table[13, 2]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 28, 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("check.combiTimeTable.verboseRead", "= true, if info message that file is loading is to be printed [:#(type=Boolean)]",\
 15, true, 0.0,0.0,0.0,0,562)
DeclareVariable("check.combiTimeTable.columns[1]", "Columns of table to be interpolated [:#(type=Integer)]",\
 29, 2, 0.0,0.0,0.0,0,517)
DeclareVariable("check.combiTimeTable.smoothness", "Smoothness of table interpolation [:#(type=Modelica.Blocks.Types.Smoothness)]",\
 30, 3, 1.0,6.0,0.0,0,517)
DeclareVariable("check.combiTimeTable.extrapolation", "Extrapolation of data outside the definition range [:#(type=Modelica.Blocks.Types.Extrapolation)]",\
 31, 1, 1.0,4.0,0.0,0,517)
DeclareVariable("check.combiTimeTable.timeScale", "Time scale of first table column [s]",\
 32, 1, 1E-15,1E+100,0.0,0,513)
DeclareParameter("check.combiTimeTable.offset[1]", "Offsets of output signals", 16,\
 0, 0.0,0.0,0.0,0,560)
DeclareVariable("check.combiTimeTable.startTime", "Output = offset for time < startTime [s]",\
 33, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("check.combiTimeTable.shiftTime", "Shift time of first table column [s]",\
 34, 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("check.combiTimeTable.timeEvents", "Time event handling of table interpolation [:#(type=Modelica.Blocks.Types.TimeEvents)]",\
 17, 1, 1.0,3.0,0.0,0,564)
DeclareVariable("check.combiTimeTable.verboseExtrapolation", "= true, if warning messages are to be printed if time is outside the table definition range [:#(type=Boolean)]",\
 35, false, 0.0,0.0,0.0,0,515)
DeclareVariable("check.combiTimeTable.t_min", "Minimum abscissa value defined in table [s]",\
 36, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("check.combiTimeTable.t_max", "Maximum abscissa value defined in table [s]",\
 37, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("check.combiTimeTable.t_minScaled", "Minimum (scaled) abscissa value defined in table [1]",\
 38, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("check.combiTimeTable.t_maxScaled", "Maximum (scaled) abscissa value defined in table [1]",\
 39, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("check.combiTimeTable.p_offset[1]", "Offsets of output signals",\
 40, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("check.combiTimeTable.tableID.id", "[:#(type=Integer)]", 41, 0, \
0.0,0.0,0.0,0,2565)
DeclareVariable("check.combiTimeTable.nextTimeEvent", "Next time event instant [s]",\
 44, 0, 0.0,0.0,0.0,0,2704)
DeclareVariable("check.combiTimeTable.nextTimeEventScaled", "Next scaled time event instant [1]",\
 45, 0, 0.0,0.0,0.0,0,2704)
DeclareVariable("check.combiTimeTable.timeScaled", "Scaled time [1]", 95, 0.0, \
0.0,0.0,0.0,0,2560)
DeclareAlias2("check.realToBoolean.u", "Connector of Real input signal", \
"check.combiTimeTable.y[1]", 1, 5, 94, 0)
DeclareAlias2("check.realToBoolean.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "bandDuration.check", 1, 5, 46, 65)
DeclareParameter("check.realToBoolean.threshold", "Output signal y is true, if input u >= threshold",\
 18, 0.5, 0.0,0.0,0.0,0,560)
DeclareVariable("check.n", "Number of table points [:#(type=Integer)]", 42, 12, \
0.0,0.0,0.0,0,2565)
DeclareVariable("bandDuration.check", "Boolean to check [:#(type=Boolean)]", 46,\
 false, 0.0,0.0,0.0,0,642)
DeclareParameter("bandDuration.window", "Length of sliding time window (> 0) [s]",\
 19, 3, 1E-15,1E+100,0.0,0,560)
DeclareVariable("bandDuration.y", "Property output signal [:#(type=Modelica_Requirements.Interfaces.PropertyOutput)]",\
 47, 1, 1.0,3.0,0.0,0,644)
DeclareParameter("bandDuration.lowerLimit", "In sliding time window, maxDuration(check=true) >= lowerLimit required [s]",\
 20, 1, 1E-15,1E+100,0.0,0,560)
DeclareParameter("bandDuration.upperLimit", "In sliding time window, maxDuration(check=true) <= upperLimit required [s]",\
 21, 2, 1E-15,1E+100,0.0,0,560)
DeclareVariable("bandDuration.maxDuration", "Longest time duration in the sliding time window where check was permanently true [s]",\
 96, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("bandDuration.buffer.T", "Length of sliding window [s]", 48, 0.0,\
 0.0,0.0,0.0,0,2688)
DeclareVariable("bandDuration.buffer.t0", "Time instant where sliding time window starts [s]",\
 49, 0.0, 0.0,0.0,0.0,0,2688)
DeclareVariable("bandDuration.buffer.t[1]", "Time instants [s]", 50, 0.0, \
0.0,0.0,0.0,0,2688)
DeclareVariable("bandDuration.buffer.t[2]", "Time instants [s]", 51, 0.0, \
0.0,0.0,0.0,0,2688)
DeclareVariable("bandDuration.buffer.t[3]", "Time instants [s]", 52, 0.0, \
0.0,0.0,0.0,0,2688)
DeclareVariable("bandDuration.buffer.t[4]", "Time instants [s]", 53, 0.0, \
0.0,0.0,0.0,0,2688)
DeclareVariable("bandDuration.buffer.t[5]", "Time instants [s]", 54, 0.0, \
0.0,0.0,0.0,0,2688)
DeclareVariable("bandDuration.buffer.t[6]", "Time instants [s]", 55, 0.0, \
0.0,0.0,0.0,0,2688)
DeclareVariable("bandDuration.buffer.t[7]", "Time instants [s]", 56, 0.0, \
0.0,0.0,0.0,0,2688)
DeclareVariable("bandDuration.buffer.t[8]", "Time instants [s]", 57, 0.0, \
0.0,0.0,0.0,0,2688)
DeclareVariable("bandDuration.buffer.t[9]", "Time instants [s]", 58, 0.0, \
0.0,0.0,0.0,0,2688)
DeclareVariable("bandDuration.buffer.t[10]", "Time instants [s]", 59, 0.0, \
0.0,0.0,0.0,0,2688)
DeclareVariable("bandDuration.buffer.t[11]", "Time instants [s]", 60, 0.0, \
0.0,0.0,0.0,0,2688)
DeclareVariable("bandDuration.buffer.t[12]", "Time instants [s]", 61, 0.0, \
0.0,0.0,0.0,0,2688)
DeclareVariable("bandDuration.buffer.t[13]", "Time instants [s]", 62, 0.0, \
0.0,0.0,0.0,0,2688)
DeclareVariable("bandDuration.buffer.t[14]", "Time instants [s]", 63, 0.0, \
0.0,0.0,0.0,0,2688)
DeclareVariable("bandDuration.buffer.t[15]", "Time instants [s]", 64, 0.0, \
0.0,0.0,0.0,0,2688)
DeclareVariable("bandDuration.buffer.t[16]", "Time instants [s]", 65, 0.0, \
0.0,0.0,0.0,0,2688)
DeclareVariable("bandDuration.buffer.t[17]", "Time instants [s]", 66, 0.0, \
0.0,0.0,0.0,0,2688)
DeclareVariable("bandDuration.buffer.t[18]", "Time instants [s]", 67, 0.0, \
0.0,0.0,0.0,0,2688)
DeclareVariable("bandDuration.buffer.t[19]", "Time instants [s]", 68, 0.0, \
0.0,0.0,0.0,0,2688)
DeclareVariable("bandDuration.buffer.t[20]", "Time instants [s]", 69, 0.0, \
0.0,0.0,0.0,0,2688)
DeclareVariable("bandDuration.buffer.b[1]", "Values at corresponding time instants [:#(type=Boolean)]",\
 70, false, 0.0,0.0,0.0,0,2690)
DeclareVariable("bandDuration.buffer.b[2]", "Values at corresponding time instants [:#(type=Boolean)]",\
 71, false, 0.0,0.0,0.0,0,2690)
DeclareVariable("bandDuration.buffer.b[3]", "Values at corresponding time instants [:#(type=Boolean)]",\
 72, false, 0.0,0.0,0.0,0,2690)
DeclareVariable("bandDuration.buffer.b[4]", "Values at corresponding time instants [:#(type=Boolean)]",\
 73, false, 0.0,0.0,0.0,0,2690)
DeclareVariable("bandDuration.buffer.b[5]", "Values at corresponding time instants [:#(type=Boolean)]",\
 74, false, 0.0,0.0,0.0,0,2690)
DeclareVariable("bandDuration.buffer.b[6]", "Values at corresponding time instants [:#(type=Boolean)]",\
 75, false, 0.0,0.0,0.0,0,2690)
DeclareVariable("bandDuration.buffer.b[7]", "Values at corresponding time instants [:#(type=Boolean)]",\
 76, false, 0.0,0.0,0.0,0,2690)
DeclareVariable("bandDuration.buffer.b[8]", "Values at corresponding time instants [:#(type=Boolean)]",\
 77, false, 0.0,0.0,0.0,0,2690)
DeclareVariable("bandDuration.buffer.b[9]", "Values at corresponding time instants [:#(type=Boolean)]",\
 78, false, 0.0,0.0,0.0,0,2690)
DeclareVariable("bandDuration.buffer.b[10]", "Values at corresponding time instants [:#(type=Boolean)]",\
 79, false, 0.0,0.0,0.0,0,2690)
DeclareVariable("bandDuration.buffer.b[11]", "Values at corresponding time instants [:#(type=Boolean)]",\
 80, false, 0.0,0.0,0.0,0,2690)
DeclareVariable("bandDuration.buffer.b[12]", "Values at corresponding time instants [:#(type=Boolean)]",\
 81, false, 0.0,0.0,0.0,0,2690)
DeclareVariable("bandDuration.buffer.b[13]", "Values at corresponding time instants [:#(type=Boolean)]",\
 82, false, 0.0,0.0,0.0,0,2690)
DeclareVariable("bandDuration.buffer.b[14]", "Values at corresponding time instants [:#(type=Boolean)]",\
 83, false, 0.0,0.0,0.0,0,2690)
DeclareVariable("bandDuration.buffer.b[15]", "Values at corresponding time instants [:#(type=Boolean)]",\
 84, false, 0.0,0.0,0.0,0,2690)
DeclareVariable("bandDuration.buffer.b[16]", "Values at corresponding time instants [:#(type=Boolean)]",\
 85, false, 0.0,0.0,0.0,0,2690)
DeclareVariable("bandDuration.buffer.b[17]", "Values at corresponding time instants [:#(type=Boolean)]",\
 86, false, 0.0,0.0,0.0,0,2690)
DeclareVariable("bandDuration.buffer.b[18]", "Values at corresponding time instants [:#(type=Boolean)]",\
 87, false, 0.0,0.0,0.0,0,2690)
DeclareVariable("bandDuration.buffer.b[19]", "Values at corresponding time instants [:#(type=Boolean)]",\
 88, false, 0.0,0.0,0.0,0,2690)
DeclareVariable("bandDuration.buffer.b[20]", "Values at corresponding time instants [:#(type=Boolean)]",\
 89, false, 0.0,0.0,0.0,0,2690)
DeclareVariable("bandDuration.buffer.first", "Index of first element in buffer [:#(type=Integer)]",\
 90, 0, 0.0,0.0,0.0,0,2692)
DeclareVariable("bandDuration.buffer.last", "Index of last element in buffer [:#(type=Integer)]",\
 91, 0, 0.0,0.0,0.0,0,2692)
DeclareVariable("bandDuration.buffer.nElem", "Number of elements in the buffer [:#(type=Integer)]",\
 92, 0, 0.0,0.0,0.0,0,2692)
DeclareVariable("bandDuration.t_first", "[s]", 43, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("bandDuration.first", "[:#(type=Boolean)]", 93, false, 0.0,0.0,\
0.0,0,2690)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
}
StartDataBlock
StartPreBlock
preW(DYNX(W_,48),"bandDuration.buffer.T", 0.0, 3);
preW(DYNX(W_,70),"bandDuration.buffer.b[1]", false, 4);
preW(DYNX(W_,71),"bandDuration.buffer.b[2]", false, 5);
preW(DYNX(W_,72),"bandDuration.buffer.b[3]", false, 6);
preW(DYNX(W_,73),"bandDuration.buffer.b[4]", false, 7);
preW(DYNX(W_,74),"bandDuration.buffer.b[5]", false, 8);
preW(DYNX(W_,75),"bandDuration.buffer.b[6]", false, 9);
preW(DYNX(W_,76),"bandDuration.buffer.b[7]", false, 10);
preW(DYNX(W_,77),"bandDuration.buffer.b[8]", false, 11);
preW(DYNX(W_,78),"bandDuration.buffer.b[9]", false, 12);
preW(DYNX(W_,79),"bandDuration.buffer.b[10]", false, 13);
preW(DYNX(W_,80),"bandDuration.buffer.b[11]", false, 14);
preW(DYNX(W_,81),"bandDuration.buffer.b[12]", false, 15);
preW(DYNX(W_,82),"bandDuration.buffer.b[13]", false, 16);
preW(DYNX(W_,83),"bandDuration.buffer.b[14]", false, 17);
preW(DYNX(W_,84),"bandDuration.buffer.b[15]", false, 18);
preW(DYNX(W_,85),"bandDuration.buffer.b[16]", false, 19);
preW(DYNX(W_,86),"bandDuration.buffer.b[17]", false, 20);
preW(DYNX(W_,87),"bandDuration.buffer.b[18]", false, 21);
preW(DYNX(W_,88),"bandDuration.buffer.b[19]", false, 22);
preW(DYNX(W_,89),"bandDuration.buffer.b[20]", false, 23);
preW(DYNX(W_,90),"bandDuration.buffer.first", 0, 24);
preW(DYNX(W_,91),"bandDuration.buffer.last", 0, 25);
preW(DYNX(W_,92),"bandDuration.buffer.nElem", 0, 26);
preW(DYNX(W_,50),"bandDuration.buffer.t[1]", 0.0, 27);
preW(DYNX(W_,51),"bandDuration.buffer.t[2]", 0.0, 28);
preW(DYNX(W_,52),"bandDuration.buffer.t[3]", 0.0, 29);
preW(DYNX(W_,53),"bandDuration.buffer.t[4]", 0.0, 30);
preW(DYNX(W_,54),"bandDuration.buffer.t[5]", 0.0, 31);
preW(DYNX(W_,55),"bandDuration.buffer.t[6]", 0.0, 32);
preW(DYNX(W_,56),"bandDuration.buffer.t[7]", 0.0, 33);
preW(DYNX(W_,57),"bandDuration.buffer.t[8]", 0.0, 34);
preW(DYNX(W_,58),"bandDuration.buffer.t[9]", 0.0, 35);
preW(DYNX(W_,59),"bandDuration.buffer.t[10]", 0.0, 36);
preW(DYNX(W_,60),"bandDuration.buffer.t[11]", 0.0, 37);
preW(DYNX(W_,61),"bandDuration.buffer.t[12]", 0.0, 38);
preW(DYNX(W_,62),"bandDuration.buffer.t[13]", 0.0, 39);
preW(DYNX(W_,63),"bandDuration.buffer.t[14]", 0.0, 40);
preW(DYNX(W_,64),"bandDuration.buffer.t[15]", 0.0, 41);
preW(DYNX(W_,65),"bandDuration.buffer.t[16]", 0.0, 42);
preW(DYNX(W_,66),"bandDuration.buffer.t[17]", 0.0, 43);
preW(DYNX(W_,67),"bandDuration.buffer.t[18]", 0.0, 44);
preW(DYNX(W_,68),"bandDuration.buffer.t[19]", 0.0, 45);
preW(DYNX(W_,69),"bandDuration.buffer.t[20]", 0.0, 46);
preW(DYNX(W_,49),"bandDuration.buffer.t0", 0.0, 47);
pre(DYNX(W_,46),"bandDuration.check", false, 2);
pre(DYNX(W_,44),"check.combiTimeTable.nextTimeEvent", 0, 0);
pre(DYNX(W_,45),"check.combiTimeTable.nextTimeEventScaled", 0, 1);
EndPreBlock
UpdateQEvaluate(4)
EndDataBlock
